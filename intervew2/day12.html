<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
    </style>
</head>

<body class="clearfix">

    <script type="text/javascript">

        //1.在node中执行下面的代码，求输出 
        setInterval(() => {
            console.log('setInterval')
        }, 100)

        process.nextTick(function tick() {
            process.nextTick(tick)
        })
        // 运行结果：setInterval 永远不会打印出来。

        //2.执行代码，求输出
        const promise = Promise.resolve()
            .then(() => {
                return promise
            })
        promise.catch(console.error)
        // 输出：[TypeError: Chaining cycle detected for promise #]
        // 解释：promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码会导致死循环

        //3.实现LRU缓存机制
        // 最多存储n对KV;
        // 如果大于n个, 则随意剔除一个已经过期的KV;
        // 如果没有过期的KV, 则按照LRU的规则剔除一个KV;
        // 查询时如果已经过期, 则返回空;
        class LRUCache {
            constructor(capacity, intervalTime) {
                this.cache = new Map();
                this.capacity = capacity;
                this.intervalTime = intervalTime;
            }
            get(key) {
                if (!this.cache.has(key)) {
                    return null
                }
                const tempValue = this.cache.get(key)
                this.cache.delete(key);
                if (Date.now() - tempValue.time > this.intervalTime) {
                    return null
                }
                this.cache.set(key, { value: tempValue.value, time: Date.now() })
                return tempValue.value
            }
            put(key, value) {
                if (this.cache.has(key)) {
                    this.cache.delete(key)
                }
                if (this.cache.size >= capacity) { //满了
                    const keys = this.cache.keys()
                    this.cache.delete(keys.next().value)
                }
                this.cache.set(key, { value, time: Date.now() })
            }
        }

    </script>
    </div>

</body>

</html>