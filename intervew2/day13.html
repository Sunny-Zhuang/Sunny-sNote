<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <style>
    </style>
</head>

<body class="clearfix">

    <script type="text/javascript">

        //1.what is the output
        setTimeout(() => {
            console.log('setTimeout')
        }, 0)

        setImmediate(() => {
            console.log('setImmediate')
        })

        const start = Date.now()
        while (Date.now() - start < 10);
        // 输出为：
        // setTimeout
        // setImmediate

        // 因为执行timers阶段前的时间大于1ms

        //2.在node11版本后，下面的代码输出是什么？


        //3.node中的setTimeout 和 setImmediate有什么区别 
        // setImmediate() 和 setTimeout() 很类似，但是基于被调用的时机，他们也有不同表现。

        // setImmediate 设计在poll阶段完成时执行，即check阶段；
        // setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行
        // 执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时器将受进程性能的约束。举个例子，有如下代码：

        // setTimeout(() => console.log(1));
        // setImmediate(() => console.log(2));
        // 上面代码应该先输出1，再输出2，但是实际执行的时候，结果却是不确定，有时还会先输出2，再输出1。

        // 这是因为setTimeout的第二个参数默认为0。但是实际上，Node 做不到0毫秒，最少也需要1毫秒，根据官方文档，第二个参数的取值范围在1毫秒到2147483647毫秒之间。也就是说，setTimeout(f, 0)等同于setTimeout(f, 1) 。

        // 实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行setImmediate的回调函数。

        // 但是，如果是这样的情况，输出顺序就固定了，例：

        // const fs = require('fs');
        // fs.readFile('test.js', () => {
        //     setTimeout(() => console.log(1));
        //     setImmediate(() => console.log(2));
        // });
        // 在上述代码中，一定是先输出2，再输出1。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了，执行完成后再去到 timers 阶段，然后执行setTimeout。

    </script>
    </div>

</body>

</html>