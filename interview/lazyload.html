
Lazyload：有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做"惰性加载"。
intersectionobservable：传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。目前有一个新的 IntersectionObserver API，可以自动"观察"元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做"交叉观察器”。用在scroll中也无需手动节流，因为是异步的没有性能问题
html
<img src='/empty.jpg' data-src='/img/1.jpg'>
Ts
  //lazyload intersectionobservable
  ngAfterViewInit():void{
    const intersectionObervable = new IntersectionObserver((entries)=>{
      entries.forEach((item)=>{
        if(item.isIntersecting){
          item.target['src']  = item.target['dataset']['src']
          console.error('intersectionObervable',item.target['dataset']['src'])
          intersectionObervable.unobserve(item.target)
        }
      })
    },{
      rootMargin:"150px 0px"
    }
    )
    const imgs = document.querySelectorAll('[data-src]');
    imgs.forEach((item)=>{
      intersectionObervable.observe(item)
    })
    
  }



